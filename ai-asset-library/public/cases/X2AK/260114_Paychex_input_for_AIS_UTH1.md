---
title: "Paychex Agentic AI Payroll Email Processing"
description: "Paychex’s payroll operations receive a very high volume of payroll instructions via email, creating costly and error-prone manual processing. Bain built and deployed an agentic AI system that classifies and validates inbound emails, resolves account context, generates payroll submissions via internal systems, and produces customer-ready responses, supported by rigorous testing, shadow-mode experimentation, and a Control Tower for transparency."
contacts:
  - name: "Sanjin Bicanic"
    email: "sanjin.bicanic@bain.com"
  - name: "Xun Yang"
    email: "Xun.Yang@Bain.com"
  - name: "Saimon Rai"
    email: "Saimon.Rai@Bain.com"
---

## Code documentation

# Technical & AI Overview — `payroll-email-agent`
> **Scope**: This document was generated by codebase inspection of `/Users/02snb/Code/PayChex/Payroll_AI_Agent/payroll-email-agent`.  
> **Certainty convention**: statements are explicitly marked as **(Confirmed)** when grounded in code/config; **(Inferred)** when reasoned from patterns; **(Unknown / Needs manual confirmation)** when not determinable from the repo alone.

---

## 1. High-level Summary

### What the system does
- **Payroll Email Agent**: Processes payroll-related emails into structured payroll actions, using a **LangGraph** workflow, a **FastAPI** API surface, and external tool calls to Paychex services via **MCP**. (Confirmed: `README.md` L1-L3, L8-L113; `app/api/routes.py` L25-L76; `app/payroll_agent/graph/graph_builder.py` L471-L537; `app/payroll_agent/utils/mcp.py` L78-L165)
- **Two execution modes**:
  - **Local graph**: `POST /api/v1/process-email` invokes the compiled LangGraph locally via `graph.ainvoke`. (Confirmed: `app/api/routes.py` L25-L75)
  - **Orchestrated graph**: `GET /api/v1/process-email-orchestrator` (optionally background) fetches an ingest payload from **Azure Blob Storage**, tries **remote LangGraph API** invocation, and falls back to local graph; then logs to a dashboard. (Confirmed: `app/api/routes.py` L89-L200; `app/orchestrator.py` L26-L223; `app/payroll_agent/utils/langgraph_invocation.py` L15-L173; `app/payroll_agent/utils/blob_storage.py` L12-L162; `app/payroll_agent/utils/dashboard.py` L17-L72)
- **Optional queue-driven processing**: An **Azure Service Bus** background poller pulls inbound messages, runs the same orchestration, and pushes results to an outbound queue. (Confirmed: `app/main.py` L32-L41; `app/servicebus/background_service.py` L8-L93; `app/servicebus/client.py` L14-L305; `docs/servicebus.md` L1-L207)

### Technology stack (high-signal)
- **Language/runtime**: Python (requires `>=3.11`) (Confirmed: `pyproject.toml` L8)
- **Web API**: FastAPI + Uvicorn (Confirmed: `pyproject.toml` L11-L12; `app/main.py` L43-L64)
- **Agent/workflow**: LangGraph + langgraph-api + langgraph-sdk + LangChain (Confirmed: `pyproject.toml` L13-L19; `app/payroll_agent/graph/graph_builder.py`; `app/payroll_agent/utils/langgraph_invocation.py` L5-L56)
- **LLM provider integration**: OpenAI and Azure OpenAI via `langchain-openai` (Confirmed: `pyproject.toml` L17-L20; `app/payroll_agent/config/config.py` L3-L267)
- **Tool calling**: MCP via `langchain-mcp-adapters` and `MultiServerMCPClient` (Confirmed: `pyproject.toml` L32; `app/payroll_agent/utils/mcp.py` L7-L165)
- **Cloud integrations**: Azure Blob Storage, Azure Service Bus, Azure Managed Identity/Easy Auth (Confirmed: `pyproject.toml` L38-L40; `app/payroll_agent/utils/blob_storage.py` L49-L125; `app/servicebus/client.py` L90-L126; `app/payroll_agent/utils/easy_auth_client.py` L8-L36)
- **Observability**: LangSmith is configured via env vars and dependency (Confirmed: `pyproject.toml` L19; `app/payroll_agent/config/config.py` L68-L73; `README.md` L172-L179)
- **Attachment processing / multimodal**: MarkItDown + multimodal LLM-based OCR/handwriting detection (Confirmed: `pyproject.toml` L23; `app/payroll_agent/utils/attachments.py` L1-L6, L245-L345)

### Does it contain AI / ML / GenAI?
- **Yes, heavily**: This is an LLM-driven workflow with multiple LLM calls, structured outputs, tool calling, multimodal OCR/handwriting checks, and an evaluation harness. (Confirmed: `app/payroll_agent/nodes/*`; `app/payroll_agent/prompts/*.yml`; `tests/regression/payroll_agent/test_ground_truth.py`)
- **No RAG/vector DB detected**: No embeddings/vector store libraries or code paths were found aside from a single notebook mention. (Confirmed: repo search; `tests/handwriting_detection_llm_test.ipynb` is the only “embedding(s)” match)

---

## 2. Components & Modules

| Component / Module | Path(s) | Responsibility / Description |
|---|---|---|
| **FastAPI app** | `app/main.py` | API server setup + lifespan hooks; starts Service Bus background worker on startup (Confirmed: `app/main.py` L15-L64) |
| **API routes** | `app/api/routes.py`, `app/api/models/*` | Public endpoints: `/process-email`, orchestrator endpoints, Service Bus endpoints, health check (Confirmed: `app/api/routes.py` L25-L287) |
| **Payroll Orchestrator** | `app/orchestrator.py` | Fetch from blob → prepare payload → invoke remote LangGraph → local fallback → dashboard logging → response mapping (Confirmed: `app/orchestrator.py` L26-L223) |
| **LangGraph workflow** | `app/payroll_agent/graph/graph_builder.py`, `app/payroll_agent/graph/states/*` | Defines the end-to-end state machine and subgraphs (classification, lookup, processing, execution, validation, release, wrap-up) (Confirmed: `app/payroll_agent/graph/graph_builder.py` L94-L562) |
| **Node implementations (AI + tools)** | `app/payroll_agent/nodes/*.py`, `app/payroll_agent/nodes/utils/*.py` | Each node performs LLM classification/extraction, validations, or MCP tool calls; routers gate progress (Confirmed: e.g., `nodes/classification.py`, `nodes/company_worker_lookup.py`, `nodes/payroll_processing.py`, `nodes/validation.py`, `nodes/execution.py`, `nodes/release.py`, `nodes/wrap_up.py`) |
| **Prompt templates** | `app/payroll_agent/prompts/*.yml` | YAML prompt templates loaded dynamically per node (Confirmed: `app/payroll_agent/utils/prompt.py` L8-L19; example `prompts/classification.yml` L1-L275) |
| **Instruction libraries** | `app/payroll_agent/libraries/*.yml` | Domain rulebooks/guardrails used to format prompts (Confirmed: `app/payroll_agent/utils/prompt.py` L15-L19; `libraries/payroll_extraction_guide.yml` L1-L144) |
| **LLM utilities** | `app/payroll_agent/utils/llm_utils.py` | Retry wrappers, structured output helper, token counting (Confirmed: `app/payroll_agent/utils/llm_utils.py` L54-L202) |
| **LLM usage/runtime logging** | `app/payroll_agent/utils/logging.py` | Decorators for runtime capture + LLM usage capture into state (Confirmed: `app/payroll_agent/utils/logging.py` L8-L113) |
| **Model/config** | `app/payroll_agent/config/config.py` | Central settings, LLM factory (OpenAI/Azure), env var mapping, MCP server config (Confirmed: `app/payroll_agent/config/config.py` L33-L267) |
| **MCP client** | `app/payroll_agent/utils/mcp.py` | Auth token fetch, MultiServerMCPClient setup, tool discovery and invocation (Confirmed: `app/payroll_agent/utils/mcp.py` L27-L165) |
| **Remote LangGraph invocation** | `app/payroll_agent/utils/langgraph_invocation.py` | Create remote thread/run; poll for state completion; local invocation helper (Confirmed: `app/payroll_agent/utils/langgraph_invocation.py` L15-L173) |
| **Azure Blob Storage** | `app/payroll_agent/utils/blob_storage.py` | Download payload and attachments using Managed Identity or SAS token fallback (Confirmed: `app/payroll_agent/utils/blob_storage.py` L12-L162, L457-L507) |
| **Attachment pipeline** | `app/payroll_agent/utils/attachments.py` | MarkItDown conversion + LLM OCR fallback + handwriting detection (Confirmed: `app/payroll_agent/utils/attachments.py` L1-L6, L245-L396) |
| **Dashboard integration** | `app/payroll_agent/utils/dashboard.py`, `app/payroll_agent/utils/easy_auth_client.py` | Post structured run output to dashboard; optionally obtains bearer token via Managed Identity for Easy Auth (Confirmed: `dashboard.py` L17-L72, L152-L193; `easy_auth_client.py` L8-L36) |
| **Azure Service Bus integration** | `app/servicebus/*` | Client/auth, background polling loop, orchestration of inbound→process→outbound (Confirmed: `app/servicebus/client.py` L14-L305; `app/servicebus/background_service.py` L8-L93; `docs/servicebus.md`) |
| **Evaluation / tests** | `tests/`, `app/payroll_agent/evaluation/*` | Unit tests + regression “ground truth” evaluation pipeline and notebooks (Confirmed: `tests/regression/payroll_agent/test_ground_truth.py`; `README.md` L298-L304) |
| **LangGraph packaging** | `langgraph.json`, `Dockerfile` | Declares graph entry points and langserve graph mapping for deploy (Confirmed: `langgraph.json` L1-L16; `Dockerfile` L18) |
| **CI/CD** | `.github/workflows/*` | Build/scan/push images + deploy to LangGraph environment and to Azure Container Apps (Confirmed: `.github/workflows/cd_agent.yml` L1-L105; `.github/workflows/cd_agent_prod.yml` L1-L105; `.github/workflows/deploy-container-app.yml` L1-L205) |

---

## 3. Architecture Diagram (text-based)

```mermaid
flowchart LR
  subgraph Inputs
    U[Upstream/RPA payload\n(ingestId, email, attachments metadata)] -->|POST /api/v1/process-email| API
    SBQ[Azure Service Bus Inbound Queue] --> SBW[ServiceBusBackgroundService]
    ORCHENDPOINT[GET /api/v1/process-email-orchestrator] --> ORCH
  end

  subgraph App["Payroll Email Agent (FastAPI + LangGraph)"]
    API[FastAPI routes\napp/api/routes.py] -->|local| LG[LangGraph compiled graph\npayroll_email_agent]
    ORCH[PayrollOrchestrator\napp/orchestrator.py] -->|fetch payload| BLOB[Azure Blob Storage\npayload + attachments]
    ORCH -->|invoke remote| RLG[Remote LangGraph API\nlanggraph_sdk]
    ORCH -->|fallback| LG
    SBW -->|process messages| SBO[ServiceBusOrchestrator]
    SBO --> ORCH
  end

  subgraph AI["AI/LLM Layer"]
    LG -->|LLM calls| LLM[OpenAI / Azure OpenAI\nvia langchain-openai]
    LG -->|tool calls| MCP[MCP client\nMultiServerMCPClient]
    LG -->|multimodal OCR/handwriting| MM[Multimodal LLM\nOCR + handwriting]
  end

  MCP -->|HTTP| MCPS[Paychex MCP Server\n(external repo)]
  MCPS -->|tools| CA[Paychex/Core Advance APIs\n(company, workers, checks, release, etc.)]

  ORCH --> DASH[Dashboard API\n/api/ingestion/event]
  API --> DASH
  AI --> LS[LangSmith (tracing)\n(if configured)]

  SBO -->|send results| SBOUT[Azure Service Bus Outbound Queue]
```

**Notes**
- **Remote LangGraph API** is optional and controlled by `LANGGRAPH_API_URL`; local graph is always available. (Confirmed: `app/payroll_agent/config/config.py` L74-L76; `app/orchestrator.py` L71-L94; `app/payroll_agent/utils/langgraph_invocation.py` L15-L74)
- **MCP server details** are external to this repo (referenced in `README.md`). Tool schemas/behavior must be confirmed in the MCP server repo. (Confirmed: `README.md` L125-L137; Unknown: actual tool contract details)

---

## 4. Core Feature Flows / Critical Paths

### Feature A — Process an email end-to-end (local)

#### What it does
Takes an email payload and runs the full LangGraph workflow locally, returning a structured response. (Confirmed)

#### Entry points
- `POST /api/v1/process-email` (Confirmed: `app/api/routes.py` L25-L75)

#### Flow & modules involved (with code anchors)
- **Parse input → build graph state**: `parse_upstream_model` → `InputState` → `PayrollState` (Confirmed: `app/api/routes.py` L45-L55)
- **Run graph**: `result_state = await graph.ainvoke(...)` (Confirmed: `app/api/routes.py` L58-L64)
- **Format response**: `format_payroll_state_response(result_state)` (Confirmed: `app/api/routes.py` L67-L74)

#### AI involvement
- The graph executes subgraphs that call LLMs with structured outputs and tool-calling agents (see Feature D). (Confirmed: `app/payroll_agent/graph/graph_builder.py` L471-L537)

#### External dependencies
- Depends on MCP server availability for tool calls (company lookup, workers lookup, payroll submission, etc.). (Confirmed: MCP usage throughout `app/payroll_agent/nodes/*`; Unknown: actual remote dependencies behind MCP tools)

#### Edge cases / error handling
- Errors are caught and returned as HTTP 500 with details. (Confirmed: `app/api/routes.py` L77-L86)

---

### Feature B — Orchestrated processing from ingest ID (blob + remote graph + fallback)

#### What it does
Given an `ingest_id`, fetches payload from blob storage, normalizes it, runs remote LangGraph if configured, falls back to local graph if needed, logs to dashboard, and returns a status object. (Confirmed)

#### Entry points
- `GET /api/v1/process-email-orchestrator?ingest_id=...&background=true|false` (Confirmed: `app/api/routes.py` L89-L177)
- Background mode enqueues an in-process async task and immediately returns 200. (Confirmed: `app/api/routes.py` L117-L136, L179-L200)

#### Flow & modules involved (with code anchors)
- **Fetch**: `BlobStorageClient.download_json(ingest_id, "payload.json")` (Confirmed: `app/orchestrator.py` L56-L66; `app/payroll_agent/utils/blob_storage.py` L144-L162)
- **Prepare**: `_prepare_payload` extracts email body (prefers `bodyThreaded` → HTML→plain text), timestamp, attachments, and sets `x_payx_sid` (Confirmed: `app/orchestrator.py` L406-L513)
- **Invoke remote LangGraph** (if `LANGGRAPH_API_URL` set):
  - Create thread, create run, poll thread state, then parse `PayrollState(**thread_state["values"])` (Confirmed: `app/payroll_agent/utils/langgraph_invocation.py` L15-L140)
- **Fallback to local LangGraph**: `graph.ainvoke(PayrollState(...))` (Confirmed: `app/orchestrator.py` L515-L582)
- **Dashboard logging**: `DashboardIntegration.log_transaction(...)` (Confirmed: `app/orchestrator.py` L108-L116; `app/payroll_agent/utils/dashboard.py` L42-L72)

#### AI involvement
- Same workflow as local processing once the graph is invoked. (Confirmed)

#### External dependencies
- **Azure Blob Storage**:
  - Uses Managed Identity in non-local modes (Confirmed: `app/payroll_agent/utils/blob_storage.py` L49-L105)
  - Uses SAS token when `ENV_MODE=LOCAL_DEV` or Managed Identity unavailable (Confirmed: `app/payroll_agent/utils/blob_storage.py` L42-L47, L122-L142)
- **Dashboard API**: posts to `/api/ingestion/event`; may use Easy Auth bearer tokens via Managed Identity. (Confirmed: `app/payroll_agent/utils/dashboard.py` L152-L188; `app/payroll_agent/utils/easy_auth_client.py` L31-L36)

#### Edge cases / error handling
- Remote LangGraph invocation uses retries and timeouts; falls back to local if remote fails. (Confirmed: `app/orchestrator.py` L71-L94; `app/payroll_agent/utils/langgraph_invocation.py` L35-L74)
- Orchestrator has a “skeleton failure” response builder to ensure dashboard payloads have required keys even on failure. (Confirmed: `app/orchestrator.py` L265-L357)

---

### Feature C — Queue-driven processing (Service Bus)

#### What it does
Polls inbound Service Bus messages, processes each through the orchestrator, sends results to an outbound queue. (Confirmed)

#### Entry points
- Automatic: FastAPI lifespan starts the background poller. (Confirmed: `app/main.py` L15-L41; `app/servicebus/background_service.py` L31-L45)
- Manual: `POST /api/v1/process-email-servicebus-orchestrator` (Confirmed: `app/api/routes.py` L202-L266)
- Health: `GET /api/v1/servicebus-health` (Confirmed: `app/api/routes.py` L268-L287)

#### External dependencies
- Azure Service Bus via Managed Identity (Easy Auth) or connection string for local. (Confirmed: `app/servicebus/client.py` L73-L156)

---

### Feature D — The AI “graph” workflow (subgraphs + nodes)

The LangGraph is composed of 7 major stages connected with conditional routing. (Confirmed: `app/payroll_agent/graph/graph_builder.py` L471-L537)

#### Stage 1: Classification (triage + knockouts + request type + complexity)
- **Purpose**: Decide if email is payroll-related and safe to process; apply “knockout rules” and determine request type/complexity. (Confirmed: `README.md` L115-L118; `app/payroll_agent/nodes/classification.py`)
- **Key logic**:
  - **Intent triage via structured LLM**: `IntentTriage` schema output; catches Azure content filtering failures (`BadRequestError` with `code=="content_filter"`) and flags policy violation. (Confirmed: `app/payroll_agent/nodes/classification.py` L49-L113)
  - **Batched knockout evaluation**: runs multiple batches concurrently (semaphore capped at 10) using prompts that embed scenario rules. (Confirmed: `app/payroll_agent/nodes/classification.py` L170-L277; `app/payroll_agent/prompts/classification.yml` L89-L139)
  - **Rule-based routing thresholds**: uses `routers_config.yml` and `rules_config.yml` (Confirmed: `app/payroll_agent/nodes/classification.py` L33-L38; Unknown: exact thresholds without reading YAMLs here)

#### Stage 2: Company & worker lookup (MCP tools + LLM matching)
- **Purpose**: Resolve company from displayId(s), retrieve workers/notes/holds, process attachments, pick pay period, and build agent context. (Confirmed: `app/payroll_agent/nodes/company_worker_lookup.py`; `app/payroll_agent/graph/graph_builder.py` L153-L257)
- **AI + tool usage**:
  - **Company lookup**: MCP tool `paychex_company_lookup` for each displayId; if multiple companies, use LLM scoring with worker rosters fetched via MCP. (Confirmed: `company_worker_lookup.py` L107-L213; `nodes/utils/company_worker_lookup.py` L97-L188)
  - **Worker matching**: Two-step structured LLM: detect request type (`WorkerRequestType`) then match workers (`WorkerMatchResult`), incorporating company notes. (Confirmed: `company_worker_lookup.py` L369-L517)
  - **Pay period selection**: MCP tool `paychex_company_pay_periods` then LLM selects `MatchedPayPeriod`; off-cycle pay periods rejected if missing `intervalCode` (fraud risk). (Confirmed: `company_worker_lookup.py` L557-L617)
  - **Attachment processing**: downloads attachments from blob; MarkItDown conversion + LLM OCR fallback; separate handwriting detection. (Confirmed: `company_worker_lookup.py` L216-L274; `app/payroll_agent/utils/blob_storage.py` L457-L507; `app/payroll_agent/utils/attachments.py` L369-L396)

#### Stage 3: Payroll processing (multi-agent extraction + consensus)
- **Purpose**: Extract payroll “commands” (per worker) from email using tool-calling ReAct agents; require agreement between two agents for safety. (Confirmed: `app/payroll_agent/nodes/payroll_processing.py` L28-L245)
- **AI pattern**:
  - `create_react_agent` with MCP tools `paychex_company_checks`, `paychex_get_rateId`. (Confirmed: `payroll_processing.py` L6-L57)
  - Two agents run in parallel; results compared with `_commands_match`; mismatch terminates “for safety”. (Confirmed: `payroll_processing.py` L202-L245)
  - Prompts are heavily rule-based via YAML + library injection (`format_base_agent_prompt`). (Confirmed: `payroll_processing.py` L49-L56; `app/payroll_agent/utils/prompt.py` L89-L104; `libraries/payroll_extraction_guide.yml` L55-L74)

#### Stage 4: Execution (submit payroll checks via MCP)
- **Purpose**: Convert processed commands into per-worker earnings payloads and call MCP tool(s) to create worker checks. (Confirmed: `app/payroll_agent/nodes/execution.py` L84-L326)
- **Safety gates**:
  - **Environment gating**: if `ENV_MODE != 'PRODUCTION'`, complexity router proceeds automatically; real execution still uses MCP calls but overall release step is gated elsewhere. (Confirmed: `execution.py` L58-L61; `release.py` L220-L225)
  - **Duplicate component check**: detects and blocks duplicate component IDs (recurring components) before proceeding. (Confirmed: `execution.py` L290-L359)

#### Stage 5: Validation (late-stage knockouts + completeness evaluation)
- **Purpose**: Tool-calling validation agent checks business rules; additional LLM “completeness evaluator” verifies nothing is missed. (Confirmed: `app/payroll_agent/nodes/validation.py` L22-L243; `app/payroll_agent/nodes/utils/validation.py` L29-L115)
- **AI patterns**:
  - ReAct validation agent binds MCP tools and returns `response_format=LateStageKnockouts`. (Confirmed: `nodes/utils/validation.py` L97-L109)
  - Completeness evaluation uses reasoning model with `reasoning_effort="medium"` and threshold gating. (Confirmed: `nodes/validation.py` L132-L234)

#### Stage 6: Release (verification decision + holds + optional preprocessing reports)
- **Purpose**: Decide whether to release without verification, retrieve holds, possibly create preprocessing reports, release payroll (production only), and summarize. (Confirmed: `app/payroll_agent/nodes/release.py`)
- **Environment gating**:
  - **Release MCP call** only happens in `ENV_MODE == 'PRODUCTION'`. (Confirmed: `release.py` L220-L251)

#### Stage 7: Wrap-up (CSA notes + email responses)
- **Purpose**: When knockouts/system errors/partial submissions occur, generate CSA notes; optionally post notes via MCP; generate customer email response templates. (Confirmed: `app/payroll_agent/nodes/wrap_up.py` L31-L336)

---

## 5. Data Model, Storage & Governance

### Data models & persistence
- **Primary state object**: `PayrollState` with nested per-stage output states, passed through LangGraph. (Confirmed: referenced across nodes and graph builder; e.g., `app/payroll_agent/graph/graph_builder.py` L3-L5)
- **External API models**: Pydantic request/response for FastAPI. (Confirmed: `app/api/models/*`; used in `app/api/routes.py` L9-L15)
- **Structured LLM outputs**: Pydantic models per stage (e.g., `IntentTriage`, `WorkerMatchResult`, `PayrollResponse`, late-stage knockouts). (Confirmed: `app/payroll_agent/nodes/classification.py` L9-L21; `company_worker_lookup.py` L8-L18; `payroll_processing.py` L16; `nodes/utils/validation.py` L20-L22)

### Storage systems
- **Azure Blob Storage**:
  - Stores orchestrator payloads as JSON and attachments under `{ingestId}/attachments/…`. (Confirmed: `app/orchestrator.py` L57-L66; `app/payroll_agent/utils/blob_storage.py` L457-L499)
- **Azure Service Bus**:
  - Inbound/outbound queues for message processing (Confirmed: `app/servicebus/client.py` L37-L52)
- **Dashboard API**:
  - Receives event payloads at `/api/ingestion/event` and complexity checks at `/api/assurer/evaluate`. (Confirmed: `app/payroll_agent/utils/dashboard.py` L158-L188, L194-L247)
- **LangGraph checkpointing**:
  - Uses `MemorySaver` for ReAct agent tool-calling sessions (in-memory). (Confirmed: `app/payroll_agent/nodes/payroll_processing.py` L7-L57)

### Data types & sensitivity
- **Likely PII / sensitive**: Email bodies, sender addresses/domains, employee names, worker IDs, pay amounts/hours/rates, pay period IDs. (Confirmed: email and payroll fields used throughout; e.g., `app/api/routes.py` L45-L75; `app/orchestrator.py` L436-L507; `company_worker_lookup.py` L369-L517; `payroll_processing.py` L65-L76)
- **Logging choices**: Some potentially PII-rich logs are commented out (e.g., company name in lookup). (Confirmed: `app/payroll_agent/nodes/company_worker_lookup.py` L152-L153; `execution.py` L189-L194)
- **Unknown / Needs manual confirmation**: Data retention and access controls in the dashboard backend and blob storage lifecycle policies are not defined here.

---

## 6. AI / ML / GenAI Capabilities

### Patterns detected
- **LLM classification / routing**: intent triage, knockout classification, request type classification. (Confirmed: `app/payroll_agent/nodes/classification.py` L49-L501; `prompts/classification.yml`)
- **Tool-calling agents (ReAct)**:
  - Payroll extraction agents call MCP tools to fetch “same as last time” checks and to resolve rate IDs. (Confirmed: `app/payroll_agent/nodes/payroll_processing.py` L35-L57; `libraries/payroll_extraction_guide.yml` L36-L54)
  - Validation agent calls MCP tools to validate check date/salary/recent hire, returning structured knockout results. (Confirmed: `app/payroll_agent/nodes/utils/validation.py` L41-L109)
- **Multi-agent safety via consensus**: Two payroll extraction agents run and results must match or terminate. (Confirmed: `app/payroll_agent/nodes/payroll_processing.py` L202-L245)
- **Multimodal processing**:
  - Attachment OCR uses a multimodal LLM model and structured schema (`TextExtractionResult`). (Confirmed: `app/payroll_agent/utils/attachments.py` L245-L283)
  - Handwriting detection uses multimodal LLM and returns `AttachmentHandwrittenAnalysis`. (Confirmed: `app/payroll_agent/utils/attachments.py` L285-L345)
- **Governance-style controls**:
  - Content filter handling (Azure content filtering surfaced as `BadRequestError`), causes safe termination. (Confirmed: `app/payroll_agent/nodes/classification.py` L84-L113)
  - Rule-based “knockout” concept with configured thresholds. (Confirmed: `docs/Security_measures.md` L17-L21; `app/payroll_agent/nodes/classification.py` L311-L419; `app/payroll_agent/nodes/validation.py` L66-L79)

### RAG / retrieval / vector search
- **Not present**: No embedding generation or vector store integration detected in code. (Confirmed: repository search; only a notebook mention)

---

## 7. Models, Providers & Orchestration

### Providers and model selection
- **Providers**:
  - **OpenAI** via `ChatOpenAI` (Confirmed: `app/payroll_agent/config/config.py` L3-L4, L253-L265)
  - **Azure OpenAI** via `AzureChatOpenAI` with `API_VERSION` and `AZURE_ENDPOINT` (Confirmed: `app/payroll_agent/config/config.py` L230-L252)
- **Default model names configured** (can be overridden by env):
  - Reasoning: `LLM_MODEL_REASONING="o4-mini"` (Confirmed: `app/payroll_agent/config/config.py` L46)
  - Multimodal: `LLM_MODEL_MULTI_MODAL="gpt-4o"` (Confirmed: `app/payroll_agent/config/config.py` L47)
  - “Non-reasoning” / secondary: `gpt-41`, `gpt-41`-like labels (Confirmed: `app/payroll_agent/config/config.py` L48-L49)
  - **Unknown / Needs manual confirmation**: Whether these correspond to exact provider model IDs in your environment (e.g., `gpt-4.1` vs `gpt-41`) and what’s deployed on Azure.

### Orchestration framework(s)
- **LangGraph StateGraph**:
  - Defines nodes, parallel branches, convergence points, and conditional routing per stage. (Confirmed: `app/payroll_agent/graph/graph_builder.py` L94-L562)
- **Remote graph serving**:
  - `langgraph.json` maps graph IDs to Python symbols for langgraph-api/Studio. (Confirmed: `langgraph.json` L1-L16)
  - `Dockerfile` sets `LANGSERVE_GRAPHS` to match graph exports (Confirmed: `Dockerfile` L18)

### Prompt templates and management
- Prompts are stored as YAML per node and loaded via `load_prompt(name)` with memoization. (Confirmed: `app/payroll_agent/utils/prompt.py` L8-L13)
- Large “rulebook” content is injected into prompts from YAML libraries (`format_base_agent_prompt`). (Confirmed: `app/payroll_agent/utils/prompt.py` L89-L104; `libraries/payroll_extraction_guide.yml`)
- **No explicit prompt versioning system** beyond repository versioning and `version.yml` (Confirmed: version is referenced in tests; Unknown: governance process outside repo).

---

## 8. Configuration, Deployment & Infrastructure

### Configuration mechanisms
- **Pydantic Settings** loads `.env` plus environment variables, supports nested env var names with `__`. (Confirmed: `app/payroll_agent/config/config.py` L107-L112)
- Key AI config env vars include:
  - `OPENAI_API_KEY`, `LLM_TYPE`, `AZURE_ENDPOINT`, `API_VERSION`, model names, `LANGCHAIN_*`, `LANGGRAPH_API_URL`. (Confirmed: `README.md` L166-L195; `app/payroll_agent/config/config.py` L42-L76)
- MCP is configured via `MCP_SERVERS__{NAME}__*` keys. (Confirmed: `docker-compose.yml` L16-L20; `app/payroll_agent/config/config.py` L86-L90)

### Containerization
- **Local dev** uses `docker-compose.yml` to run FastAPI (8000) and LangGraph playground (2024). (Confirmed: `README.md` L230-L254; `docker-compose.yml` L1-L58)
- **LangGraph API image** uses base `langchain/langgraph-api` and sets `LANGSERVE_GRAPHS`. (Confirmed: `Dockerfile` L1-L29)

### CI/CD and deployment
- **LangGraph environment deployment (dev/prod-shadow)**:
  - Builds/scans/pushes image via a shared workflow and deploys using `paychex/actions-langgraph-deployment-action@v1`. (Confirmed: `.github/workflows/cd_agent.yml` L36-L105; `.github/workflows/cd_agent_prod.yml` L36-L105)
- **Azure Container Apps deployment**:
  - Reusable workflow builds `Dockerfile.agent`, pushes to ACR, and updates a container app with env vars. (Confirmed: `.github/workflows/deploy-container-app.yml` L109-L195)
- **Cloud provider**: Azure is explicitly used (Container Apps, ACR, Managed Identity, Service Bus, Blob Storage). (Confirmed)

---

## 9. Data, Governance & Safety

### Safety mechanisms (repo-evidenced)
- **Content filtering / prompt injection**:
  - Classification catches Azure OpenAI content filter violations and terminates safely. (Confirmed: `app/payroll_agent/nodes/classification.py` L84-L113)
  - Documentation claims prompt injection detection + content filtering categories. (Confirmed in docs, but implementation details beyond content_filter catch are **Unknown / Needs manual confirmation**: `docs/Security_measures.md` L6-L15)
- **Knockout rules**:
  - Multiple knockout passes: early (classification) and late-stage (validation), both thresholded. (Confirmed: `docs/Security_measures.md` L17-L21; `app/payroll_agent/nodes/classification.py` L311-L419; `app/payroll_agent/nodes/validation.py` L66-L79)
- **Multi-agent agreement requirement** for payroll extraction commands reduces single-model hallucination risk. (Confirmed: `app/payroll_agent/nodes/payroll_processing.py` L202-L245)
- **Off-cycle pay period rejection**:
  - Rejects pay periods missing `intervalCode`, explicitly citing fraud risk. (Confirmed: `app/payroll_agent/nodes/company_worker_lookup.py` L603-L610)
- **Environment gating**:
  - High-risk side effects (e.g., releasing payroll) are limited to `ENV_MODE == 'PRODUCTION'`. (Confirmed: `app/payroll_agent/nodes/release.py` L220-L251)

### Inferred risks / trade-offs
- **(Inferred risk)**: Some nodes return `{}` instead of `state` in multiple places, which may rely on LangGraph behavior to merge state updates, but can also be a bug source if not intentional. Examples: `classification_technical_knockout_batched` returns `{}`; several company lookup functions return `{}`. (Confirmed code pattern: `app/payroll_agent/nodes/classification.py` L308-L309; `app/payroll_agent/nodes/company_worker_lookup.py` L89-L93, L621-L622, L991-L992)
- **(Inferred risk)**: Broad retry policies (`Exception` included) can hide systematic prompt/schema issues and amplify cost/latency under persistent failure. (Confirmed: `app/payroll_agent/utils/llm_utils.py` L72-L82, L102-L115)
- **(Inferred trade-off)**: Multi-agent consensus improves safety but increases latency and token/cost ~2x for extraction stage. (Confirmed architecture; costs are inferred)

---

## 10. Cross-cutting Concerns

### Logging, monitoring & observability
- **Runtime logging per node**: `@log_runtime` stores timings into output state. (Confirmed: `app/payroll_agent/utils/logging.py` L8-L63)
- **LLM usage capture**: `log_llm_usage` stores estimated tokens + inferred model name into state. (Confirmed: `app/payroll_agent/utils/logging.py` L66-L113)
- **LangSmith**: env vars exist for LangSmith tracing integration (Confirmed: `app/payroll_agent/config/config.py` L68-L73; `README.md` L172-L179)
- **Dashboard integration**: posts entire run payload to dashboard; may include sensitive data (Confirmed: `app/payroll_agent/utils/dashboard.py` L42-L72, L152-L188)

### Testing (including AI eval)
- **Unit tests**: present under `tests/unit/...` (Confirmed: repo tree)
- **Regression / golden set evaluation**: `tests/regression/payroll_agent/test_ground_truth.py` formats a ground truth Excel file, runs API tests, computes metrics, and asserts thresholds (≥93%). (Confirmed: `tests/regression/payroll_agent/test_ground_truth.py` L1-L10, L305-L310, L311-L356)
- **AI-specific evaluation style**: uses structured extraction + fuzzy scoring for pay component matching and knockout analysis (Confirmed: described in `docs/run_gt_eval.md` L70-L134)

---

## 11. Limitations & Open Questions

- **MCP tool contracts**: Exact tool schemas, authorization rules, and side effects are not in this repo. (Unknown / Needs manual confirmation; see external MCP repo referenced in `README.md` L125-L127)
- **Production model mapping**: Whether model IDs like `gpt-41` are real provider IDs or internal deployment names, and which Azure deployments exist. (Unknown / Needs manual confirmation; `app/payroll_agent/config/config.py` L46-L49, L230-L252)
- **Data retention & compliance**: Blob retention policies, dashboard data retention, and any PII redaction strategy are not defined here. (Unknown)
- **Security controls depth**: Docs claim prompt injection and content filtering; the only explicit enforcement observed is Azure content filter error handling + knockout logic. Additional guardrails may exist in prompts/libraries, but runtime filters beyond that aren’t clearly implemented. (Partly Confirmed, partly Unknown: `docs/Security_measures.md` vs `nodes/classification.py` L84-L113)
- **Operational SLOs**: No explicit SLOs, rate limiting, or cost budgets in code; timeouts exist but overall performance requirements are not specified. (Unknown / Needs manual confirmation)

---

## Appendix — Key “Where to look” anchors

- **API entry point**: `app/main.py` (lifespan + router) and `app/api/routes.py` (endpoints)
- **Graph topology**: `app/payroll_agent/graph/graph_builder.py`
- **LLM/provider config**: `app/payroll_agent/config/config.py`
- **Tool calling (MCP)**: `app/payroll_agent/utils/mcp.py`
- **Prompts**: `app/payroll_agent/prompts/*.yml` and `app/payroll_agent/libraries/*.yml`
- **Evaluation**: `tests/regression/payroll_agent/test_ground_truth.py` and `docs/run_gt_eval.md`

## Insights, Learning & Anecdotes

### The business problem, in human terms
- A large share of payroll requests arrive as free‑form emails rather than through the “proper” UI flow, creating a constant stream of messy, high-stakes work for customer service teams. In one internal share-out, the scale is described as “millions of emails per year,” with fully loaded handling cost on the order of ~$10 per payroll—enough to materially hurt profitability. fileciteturn0file1
- Prior attempts to automate this workflow with traditional RPA reportedly stalled for years because the “edge cases are the norm”: typos, vague instructions (“same as last month”), conflicting guidance from account notes, and strange attachments (screenshots, handwritten notes, etc.). fileciteturn0file1turn0file2

### “Fully autonomous” doesn’t mean “reckless”
A repeated theme across the materials is the tension between autonomy and safety: payroll is a high-stakes domain, and the system must meet (or exceed) human service levels to be trusted. The solution’s philosophy was:
- Run autonomously where confidence is high.
- Stop early and hand off when the request is risky, ambiguous, outside scope, or fails validation gates.
- Make decisions auditable and visible through monitoring and structured logging (“Control Tower”). fileciteturn0file1turn0file2

### Key design choices that made it work in the real world
**1) A workflow of subgraphs, not “one big agent”.**  
Instead of letting a single agent decide everything end-to-end each time, the team decomposed the problem into staged subgraphs (e.g., triage → classifier/knockouts → account resolution → processing → validation → release → handover). This improved reliability, debuggability, and made it easier to halt the flow before errors propagate. fileciteturn0file1turn0file2

**2) Deterministic orchestration + bounded autonomy.**  
The “critical path” is orchestrated as a DAG-like workflow, while specific steps use instructed/tool-calling agents where the problem benefits from flexible reasoning. This balances consistency with the ability to handle messy language. fileciteturn0file1turn0file2

**3) Guardrails in two places: early knockouts and late validation.**  
Early stages filter out non-payroll or out-of-scope requests; later stages run customer-defined rules and additional checks before release. This was framed as “input governance” + “output governance,” with explicit thresholds and decision gates. fileciteturn0file2

**4) “Two independent agents must agree” before proceeding.**  
For high-risk extraction (turning natural language into payroll commands), two agents independently generate commands and the system proceeds only when they match—an intentional safety design to reduce single-model hallucinations. fileciteturn0file1turn0file2

**5) Complexity evaluation informed by historical failure modes.**  
Instead of purely “can the model do it,” the system checks “is this pattern historically safe to auto-submit?” The team described building rules by analyzing where the agent didn’t “nail it” and routing similar-looking requests away from fully autonomous submission. Shadow mode was foundational to building this evaluator. fileciteturn0file1turn0file2

**6) Separate reasoning from integration via MCP.**  
Model Context Protocol (MCP) servers abstract access to core Paychex systems. This keeps the agent’s core logic model-centric and environment-agnostic, while enabling read/write actions against production systems through controlled tools. fileciteturn0file1turn0file2

### Testing was the product
The materials emphasize that conventional “test cases alone” are insufficient for autonomous systems in interactive, messy environments.

**Golden set → offline scale → shadow testing.**  
- Golden truth tests began early and expanded into a curated set (described as ~200+ examples in one share-out) used to validate prompt and model changes like production code. fileciteturn0file1turn0file2  
- Offline testing scaled to thousands of historical emails.  
- Shadow testing then put the agent into a read-only “practice” mode on real live traffic (drafting checks but not releasing), enabling 10x–100x more realistic evaluation and accelerating improvement. fileciteturn0file2

**A lived anecdote about “the wild”.**  
One speaker notes that accuracy looked strong in early controlled testing but dropped meaningfully when broader historical and then live shadow traffic was introduced, because real customer behavior is far messier than curated samples. The point wasn’t the drop—it was that shadow mode let the team learn quickly and recover performance with high confidence. fileciteturn0file1turn0file2

### The Control Tower: more than dashboards
The Control Tower was described as a lightweight BI layer that became mission-critical: a recorder of ingestions, evaluator for outcomes, and analyst-facing UI for debugging and trust-building. It provided stage-by-stage outcomes (including knockouts), logs for deep dives, and visibility across both live and shadow traffic—turning agent behavior into something stakeholders could inspect, not just “believe.” fileciteturn0file2

### Team process learnings (“how it got built”)
Across the internal share-out, a few process patterns stand out:
- **“Fly in formation”**: tight pairing of product and technical leadership, short decision loops, and fast iteration without chaos. fileciteturn0file2
- **Production readiness is not a phase at the end**: reliability, monitoring, and live API behavior were treated as first-class from day one. fileciteturn0file2
- **Shift ownership to SMEs where possible**: externalizing business logic into client-managed YAML libraries increased client ownership and sped up iteration. fileciteturn0file1turn0file2
- **Change management mattered**: comms plans, training guides, piloting with frontline validation, and thoughtful handling of customer messaging were built alongside the tech to drive adoption. fileciteturn0file2

### Outcome framing
Reported outcomes vary slightly by artifact, but the narrative is consistent: high accuracy on payroll interactions, a growing subset that can be processed fully automatically, and very large cost-to-serve reduction potential when scaled. fileciteturn0file1turn0file2
